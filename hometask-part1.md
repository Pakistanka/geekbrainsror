## 1 часть. Овтетьте на вопросы и прокомментируйте почему так происходит.

> Для выполнения задания копируете это себе через fork. В поле "ответ" указываете ответ, в поле "почему" пишете ваше понимание почему это так работает с точки зрения языка.

1) Присвойте переменной x значение 5.

```ruby
# ответ (пример):
x = 5

# почему: все так потому что присвоение в языке идет через одиночный знак равенства, порядок присвоения идет справа налево.
```

2) Какой тип данных имеет это выражение?

```ruby
"Bob"

# ответ: строка
# почему: значение содержащееся в "" или '' имеют тип данных строка
```

3) x это строка?

```ruby
x = 5
# ответ: х - не строка
# почему: х - переменная которая принимает значение, которое в сою очередь может быть строкой.
```

4) Что будет результатом выполнения?

```ruby
"HEL" + "LO"
# ответ: "HelLo"
# почему: при сложении строк происходит конкатенация.
```

5) Что будет результатом выполнения?

```ruby
"Hel".+("lo")
# ответ: "Hello"
# почему: в данном случае точкой мы вызываем метод + с параметром "lo" (Спасибо Poignant.Guide!)
```

6) Что будет результатом выполнения?

```ruby
"Hel" + 42
# ответ: Ошибка
# почему: Сложение разных типо данных дает ошибку
```

7) Что будет результатом выполнения?

```ruby
a = "OH"
b = "mygod"
a + b
# ответ: "OHmygod"
# почему: присваиваем каждой переменной значения с типом данных строка выражение складывает переменные,в результате складываются значения переменных.
```

8) Что выведет на экран?

```ruby
my_role = "Teacher"
my_role = "Student"

p my_role
# ответ: "Student"
# почему: Ruby устроен так что возвращает последнее значение переменной, в данном случае "Student" является последним значением переменной my_role.
```

9) Получите первую букву из строки:

```ruby
"GeekBrains"
# ответ: "GeekBrains"[0]
# почему: в Ruby у массивов и строк есть сходства, одно из них в том, что каждый символ строки имеет свой индекс, в зависимости от положения, благодаря индексу мы можем обратиться к символу, индекс может быть левосторонним как в примере, так и правосторонним (word[-1] выведет нам "s")
```
10) Получите с первой по треьюю букву из строки:
```ruby
"GeekBrains"
# ответ: word[0..2]
# почему: [0..2] - (range) интервал в котором мы указываем от какого индекса до какого индекса нам необходимо взять символы и вывести их.
```

11) Получите последнюю букву из строки.

```ruby
"GeekBrains"
# ответ: word[9]||word[-1] как было указано в вопросе №9
# почему: ответ в ответе №9 (немного забежал вперед)
```

12) Замените букву b на d в строке:

```ruby
"Geekbrains"
# ответ: word = "Geekbrains"
         word[4] = "d"
         word
# почему: используя возможность обратиться к любому символу строки по индексу, мы можем присвоить каждому символу в строке новое значение.
```

13) Присвойте значение "хеллоу" переменной howru?

```ruby
# ответ: howru = "хеллоу"
# почему: howru - имя переменной, = - метод присваивания, "хеллоу" - значение переменной, тип строка.
```

14) Что будет результатом выполнения?

```ruby
"Пьяный мастер" = never_sleeps
# ответ: получаем ошибку синтаксиса
# почему: компьютер (или интерпритатор, пока что с данным пониманием не очень разобрался) читает программу слева => направо, сверху вниз, поэтому, необходимо чтобы переменная которой мы присваеваем значение находилась слева.
```

15) Что будет выведено на экран?

```ruby
chtoto = "budet"
sosvem = netak
puts sosvem
# ответ: "budet" , ошибка, nil
# почему: "budet" - строка - значение переменной chtoto
# ошибку получаем изза того что мы присваеваем переменной переменную значение которой неопределено, т.к. нет значения, которое необходимо вернуть - получаем ошибку.
# nil - пустота, т.к. sosvem неопреелена, ее значение nil, возвращается nil
```

16) Какой будет результат?

```ruby
3 + 4
# ответ: 7
# почему: операция сложения
```

17) Какой будет результат?

```ruby
4 * 7
# ответ: 28
# почему: операция умножения
```

18) Какой будет результат?

```ruby
2 ** 3
# ответ: 8
# почему: ** - метод озводящий в степень (хоть что-то запомнил с первого занятия :-))
```

19) Какой будет результат?

```ruby
8 / 2
# ответ: 4
# почему: операция деление
```

20) Какой будет результат?

```ruby
3 / 2
# ответ: 1
# почему: объяснение напрашивается только такое, что выводится только целое число от деления.
```

21) Какой будет результат?

```ruby
3.0 / 2.0
# ответ: 1.5
# почему:  значения задаются в 10чном виде, поэтому езультат выводится тоже в 10м виде.
```

22) Какой будет результат?

```ruby
"i am not afraid".upcase()
# ответ: переведет все символы строки в верхний регистр
# почему: метод .upcase
```

23) Переведите в нижний регистр.

```ruby
what = "What ArE yOuAR?"
# ответ: what.downcase
# почему: метод .downcase
```

24) Конкатенируйте строки:

```ruby
what = "Прекраная "
isthis = "годнота то"
# ответ: what + isthis
# почему: складываем переменные, складываются значения, значения наших переменных имеют тип данных строка. Конкатенация -  сложение значений типа данных строка.
```
25) Переведите число 5 в строку.

```ruby
# ответ: "5"
# почему: значение содержащееся в кавычках имеет тип данных строка ("5".class)
```

26) Что тут за проблемы?

```ruby
my name = "Mr. Stupid"
# ответ: ошибка, неопределено значение переменной my
# почему: переменная либо пишется через нижнее подчеркивание my_name, либо без пробела.
```

27) Исправьте код чтобы он выполнился:

```ruby
band = "City" + 312
# ответ: band = "City" + "312"
# почему: 2 разных типа данных, "City" - строка, 312 - число
```

28) my_array - массив из значений "ruby" and "rails". Создайте свой массив с такими же значениями.

```ruby
band = "City" + 312
# ответ: my_array = ["ruby", "rails"]
# почему: = - метод присваивания, различные значения, упорядоченные и заключенные в кадратных скобках через запятую - массив.
```

29) Создайте пустой массив:

```ruby
# ответ: [] || Array.new
# почему: массив обозначается квадратными скобками, Array константа обозначающая массив, метод .new создает новый объект.
```

30) Создайте массив содержащий значения "алекс мерфи", 33, и 12.5.
```ruby
# ответ: ["алекс мерфи", 33, 12.5] || Array.new(["алекс мерфи", 33, 12.5])
# почему: ответ на вопрос №28, в методе .new в качестве аргумента взят массив.
```

31) Опишите компоненты этого выражения:

```ruby
users = ["john", "alex", "vlad"]
# ответ: переменная, = - метод присаивания, [] - массив, "john","alex","vlad" - элементы массива строкового типа
# почему: ответ выше.
```

32) Что будет результатом выражения:

```ruby
["john", "alex", "vlad"].length()
# ответ: 3
# почему: .lenhght - метод, который возвращает колличество элементов массива, еще для этих целей существует метод .size. (["john", "alex", "vlad"].size = 3)
)
```

33) Массив корректный?

```ruby
name = "sir"
age = 32
[name, age]
# ответ: да
# почему: в массиве в качестве элементов используются переменные, а уж коли в массиве в качестве переменных могут содержаться различные типы данных, чё ж ему быть некоректным?)
```

34) Получите первый элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"][0] || ["john", "alex", "vlad"][-3]||["кто", "молодец", "?"].first
# почему: тут добавился один новый метод .first - выводитнам первый элемент массива, а все остальное, про это сходство массивов и строк я отвечал в вопросе №9, не будем терять время(если принципиально можем вернуться, но я б не терял времени)
```

35) Получите последний элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"][-1] || ["john", "alex", "vlad"][2]||["john", "alex", "vlad"].last
# почему: из нового метод .last - выводит поледний елемент массива, остальное см. выше, едем дальше.
```

36) Добавьте строку "я молодец" в конец массива:

```ruby
["кто", "молодец", "?"]
# ответ: ["кто", "молодец", "?"].push("я молодец")||["кто", "молодец", "?"] << ("я молодец")||["кто", "молодец", "?"].insert(3,"я молодец")
# почему:.push и << - методы добавления елемента в массив
# .insert - метод чуть сложней предыдущих, первое значение индекс соответствующий индексу в массиве (как будто билет в кино), второе значение - будущий элемент массива, и вот с помощью этого метода наш элемент занимает место (согласно купленному билету) согласно индексу указанному в качестве первого аргумента в методе .insert, сдвигая все элементы находящиеся справа от него в право.
```

37) Что будет результом выполнения?

```ruby
5 == 5
# ответ: true
# почему: == - метод сравнения
```

38) Что будет результом выполнения?

```ruby
true = 6
# ответ: ошибка
# почему: нельзя присвоить значение правде
```

39) Продемонстрируйте что "руби" полностью эквивалентен "руби".

```ruby
# ответ: "руби" == "руби"
# почему: руби - это руби)
```

40) Что будет результом выполнения?

```ruby
4 != 4
# ответ: false
# почему: потому что 4 есть 4, этож один из четырёх законов логики
```

41) Что будет результом выполнения?

```ruby
5 > 4
# ответ: true
# почему: 5 больше 4
```

42) Что будет напечатано?

```ruby
if 5 > 4
  puts "5 больше 4"
end
# ответ: "5 больше 4"
# почему: if запускает внутрь конструкции если условие истинно
```

43) Что будет напечатано?

```ruby
if 5 < 4
  puts "5 меньше 4"
else
  puts "5 не меньше 4"
end

# ответ: "5 не меньше 4"
# почему:в if условие ложно (ведь он связывается только с true), т.к. условие не истинно, код не заходит внутрь конструкции if, else запускает внутрь конструкции (если if не пустил к себе), если условие в if ложно(false)
```

44) Что будет напечатано?

```ruby
if "алекс" == "шмалекс"
  puts "алекс это шмалекс"
elsif "череп" == "череп"
  puts "череп и есть череп"
else
  puts "что-то пошло не так"
end
# ответ: "череп и есть череп"
# почему: if - ложно, elsif - true
```

45) Что будет напечатано?

```ruby
if 15621205615123121
  puts "Ну привет"
end
# ответ: Ну привет
# почему: 0 и nil и другие не числовые значение => false,
# 0 < .. true
```

46) Что будет напечатано?

```ruby
if "ruby"
  puts "ruby это круто"
else
  puts "ruby все равно круто"
end
# ответ: ruby это круто
# почему: почему так?) поищу просвещусь.
```

47) Что будет напечатано?

```ruby
if nil
  puts "и правда nil"
else
  puts "насильно nil не будешь"
end
# ответ: насильно nil не будешь
# почему: nil => false
```

48) Что будет напечатано?

```ruby
puts "Так тоже можно печатать логические проверки" if true
# ответ: Так тоже можно печатать логические проверки
# почему: управляющая конструкция с if может распологаться с условием в конце строки, так код помещается водной строке.
```

49) Что будет напечатано?

```ruby
puts "Так тоже можно проверять если коротко" if false
# ответ: ничего
# почему: false же
```

50) Какое будет значение X?

```ruby
x = 5
x = x + 1
# ответ: 6
# почему: ruby возвращает последнее значение присвоенное переенной в данному случает это 5 + 1
```

51) Какое будет значение helloer?

```ruby
helloer = "chill"
helloer += "hippie"
# ответ: "chillheppie"
# почему: += - метод сложения?
```

52) Что будет напечатано?

```ruby
counter = 0
while counter < 3
  puts "Поехали кружиться"
  counter = counter + 1
end
# ответ:
Поехали кружиться
Поехали кружиться
Поехали кружиться
# почему: цикл ведь, кружиться будет пока выполняется условие, спасибо что не миллион)
```

53) Что будет напечатано?

```ruby
while 3 > 15
  puts "Ну все приплыли"
end
# ответ: ничего
# почему: счетчик то не мотает)
```

54) Что будет напечатано?

```ruby
while true
  puts "Бесконечность тоже конечна, только мы об этом не всегда можем знать."
end
# ответ: а я вам верил... :D
# почему: почему верил? этож подстава чистой воды!
```
